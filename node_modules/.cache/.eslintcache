[{"/Users/julietsampson/pathfinder/src/index.js":"1","/Users/julietsampson/pathfinder/src/App.js":"2","/Users/julietsampson/pathfinder/src/reportWebVitals.js":"3","/Users/julietsampson/pathfinder/src/Pathfinder/Pathfinder.jsx":"4","/Users/julietsampson/pathfinder/src/Pathfinder/Node/Node.jsx":"5","/Users/julietsampson/pathfinder/src/algorithms/dijkstra.js":"6","/Users/julietsampson/gh-website/src/index.js":"7","/Users/julietsampson/gh-website/src/App.js":"8","/Users/julietsampson/gh-website/src/reportWebVitals.js":"9","/Users/julietsampson/gh-website/src/Pathfinder/Pathfinder.jsx":"10","/Users/julietsampson/gh-website/src/algorithms/dijkstra.js":"11","/Users/julietsampson/gh-website/src/Pathfinder/Node/Node.jsx":"12"},{"size":535,"mtime":1652573700482,"results":"13","hashOfConfig":"14"},{"size":227,"mtime":1652586555040,"results":"15","hashOfConfig":"14"},{"size":362,"mtime":1652573700485,"results":"16","hashOfConfig":"14"},{"size":6277,"mtime":1652998927172,"results":"17","hashOfConfig":"14"},{"size":892,"mtime":1652842599129,"results":"18","hashOfConfig":"14"},{"size":2074,"mtime":1652842846176,"results":"19","hashOfConfig":"14"},{"size":535,"mtime":1652573700482,"results":"20","hashOfConfig":"21"},{"size":227,"mtime":1652586555040,"results":"22","hashOfConfig":"21"},{"size":362,"mtime":1652573700485,"results":"23","hashOfConfig":"21"},{"size":6277,"mtime":1652998927172,"results":"24","hashOfConfig":"21"},{"size":2074,"mtime":1652842846176,"results":"25","hashOfConfig":"21"},{"size":892,"mtime":1652842599129,"results":"26","hashOfConfig":"21"},{"filePath":"27","messages":"28","suppressedMessages":"29","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"alqjb3",{"filePath":"30","messages":"31","suppressedMessages":"32","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"33","messages":"34","suppressedMessages":"35","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"36","messages":"37","suppressedMessages":"38","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"39"},{"filePath":"40","messages":"41","suppressedMessages":"42","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43","usedDeprecatedRules":"44"},{"filePath":"45","messages":"46","suppressedMessages":"47","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"48","usedDeprecatedRules":"44"},{"filePath":"49","messages":"50","suppressedMessages":"51","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"dd5ku1",{"filePath":"52","messages":"53","suppressedMessages":"54","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"55","messages":"56","suppressedMessages":"57","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"58","messages":"59","suppressedMessages":"60","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"61","messages":"62","suppressedMessages":"63","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"64","messages":"65","suppressedMessages":"66","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/Users/julietsampson/pathfinder/src/index.js",[],[],"/Users/julietsampson/pathfinder/src/App.js",["67"],[],"/Users/julietsampson/pathfinder/src/reportWebVitals.js",[],[],"/Users/julietsampson/pathfinder/src/Pathfinder/Pathfinder.jsx",["68","69"],[],"import React, {Component} from 'react';\nimport Node from './Node/Node';\n\nimport './Pathfinder.css';\nimport { render } from '@testing-library/react';\nimport dijkstra from '../algorithms/dijkstra.js'\n\nconst START_ROW = 10;\nconst END_ROW = 10;\nconst START_COL = 20;\nconst END_COL = 36;\n\nexport default class Pathfinder extends Component {\n    constructor() {\n        super();\n        this.state = {\n            grid: [],\n            mouseIsPressed: false,\n        };\n    }\n\n    componentDidMount() {\n        const grid = getInitialGrid();\n        this.setState({grid});\n    }\n\n    handleMouseDown(row, col) {\n        const newGrid = createWall(this.state.grid, row, col);\n        this.setState({grid: newGrid, mouseIsPressed: true});\n    }\n\n    handleMouseEnter(row, col) {\n        if (!this.state.mouseIsPressed) return;\n        const newGrid = createWall(this.state.grid, row, col);\n        this.setState({grid:newGrid});\n    }\n\n    handleMouseUp() {\n        this.setState({mouseIsPressed: false});\n    }\n \n    animateDijkstra(visited, path) {\n        for (let i = 0; i<=visited.length; i++) {\n            if (i == visited.length) {\n                setTimeout(() => {\n                    this.animatePath(path);\n                }, 10 * i);\n                return;\n            }\n            setTimeout(() => {\n                const node = visited[i];\n                document.getElementById(`node-${node.row}-${node.col}`).className =\n                    'node node-visited';\n            }, 10*i);\n        }\n    }\n\n    animatePath(path) {\n        for (let i=0; i < path.length; i++) {\n            setTimeout(() => {\n                const node = path[i];\n                document.getElementById(`node-${node.row}-${node.col}`).className =\n                    'node node-path';\n            }, 50 * i);\n        }\n    }\n\n    visualizeDijkstra() {\n        const {grid} = this.state;      \n        const start = grid[START_ROW][START_COL];\n        const end = grid[END_ROW][END_COL];\n        const visited = dijkstra(grid, start, end);\n        const path = getPath(end);\n        this.animateDijkstra(visited, path);\n    }\n\n    resetGrid() {\n        const {grid} = this.state;\n        for (let row=0;row<grid.length;row++) {\n            for (let col=0;col<grid[0].length;col++) {\n                document.getElementById(`node-${row}-${col}`).className =\n                    grid[row][col].isStartNode\n                    ? 'node node-start'\n                    : grid[row][col].isEndNode\n                    ? 'node node-end'\n                    : 'node';\n                grid[row][col].isWall = false;\n                grid[row][col].visited = false;\n                grid[row][col].distance = Infinity;\n                grid[row][col].previous = null;\n            }\n        }\n    }\n\n    render() {\n        const {grid, mouseIsPressed} = this.state;\n\n        return (\n            <>\n            <header>\n                <nav className=\"title\"> \n                    <h1>Pathfinder</h1>                   \n                </nav>\n                <nav className=\"buttons\">\n                        <button onClick={() => this.visualizeDijkstra()}>\n                            Visualize Algorithm\n                        </button>\n                        <button onClick={() => this.resetGrid(grid)}>\n                            Reset Grid\n                        </button>\n                </nav>\n            </header>\n            <div class=\"description\">\n                <p>Welcome to Pathfinder! Here you can visualize Dijkstra's famous pathfinding \n                    algorithm.</p>\n                <p>The green arrow represents the starting point, and the red circle, the end point.</p>\n                <p>Simply click and drag to add walls to obstruct the path between both points, then\n                    click \"Visualize Algorithm\" when you're ready!\n                </p>\n            </div>\n            <div className=\"grid\">\n                {grid.map((row, rowIndex) => {\n                    return (\n                        <div key={rowIndex}>\n                        {row.map((node, nodeIndex) => {\n                            const{row, col, isStartNode, isEndNode, isWall} = node;\n                            return (\n                                <Node\n                                    key={nodeIndex}\n                                    col={col}\n                                    isStartNode={isStartNode}\n                                    isEndNode={isEndNode}\n                                    isWall={isWall}\n                                    mouseIsPressed = {mouseIsPressed}\n                                    onMouseDown={(row,col) => this.handleMouseDown(row, col)}\n                                    onMouseEnter={(row,col) =>\n                                        this.handleMouseEnter(row,col)\n                                    }\n                                    onMouseUp={() => this.handleMouseUp()}\n                                    row={row}></Node>\n                            );\n                        })}\n                        </div>\n                    );\n                })}\n            </div>\n            </>\n        );\n    }\n};\n\nconst getInitialGrid = () => {\n    const grid = [];\n    for (let row=0;row<20;row++) {\n        const currRow = [];\n        for (let col = 0;col<57;col++) {\n            currRow.push(createNode(col,row));\n        }\n        grid.push(currRow);\n    }\n    return grid;\n};\n\nconst getPath = (end) => {\n    const path = [];\n    let curr = end;\n    while (curr != null) {\n        path.unshift(curr);\n        curr = curr.previous;\n    }\n    return path;\n};\n\nconst createNode = (col, row) => {\n    return {\n        col,\n        row,\n        isStartNode: row === START_ROW && col === START_COL,\n        isEndNode: row === END_ROW && col === END_COL,\n        visited: false,\n        isWall: false,\n        previous: null,\n        distance: Infinity,\n    };\n};\n\nconst createWall = (grid,row,col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const wall = {\n        ...node,\n        isWall: !node.isWall,\n    };\n    console.log(\"---WALL NODE---\");\n    console.log(row);\n    console.log(col);\n    console.log(\"---------------\");\n    newGrid[row][col] = wall;\n    return newGrid;\n};","/Users/julietsampson/pathfinder/src/Pathfinder/Node/Node.jsx",["70"],[],"import { render } from '@testing-library/react';\nimport React, {Component} from 'react';\nimport './Node.css'\n\nexport default class Node extends Component {\n    render() {\n        const {\n            col,\n            isEndNode, \n            isStartNode,\n            isWall,\n            onMouseDown,\n            onMouseEnter,\n            onMouseUp,\n            row,\n        } = this.props;\n        const extraClassName = isEndNode \n        ? 'node-end' \n        : isStartNode \n        ? 'node-start'\n        : isWall\n        ? 'node-wall' \n        : '';\n        return (\n            <div\n                id={`node-${row}-${col}`} \n                className={`node ${extraClassName}`}\n                onMouseDown={() => onMouseDown(row, col)}\n                onMouseEnter={() => onMouseEnter(row, col)}\n                onMouseUp={() => onMouseUp(row, col)}\n            ></div>\n        );\n    }\n}",[],"/Users/julietsampson/pathfinder/src/algorithms/dijkstra.js",["71","72"],[],"let node = {\n    row: 0,\n    col: 0,\n    visited: false,\n    distance: Infinity,\n}\n\nexport default function dijkstra(grid, startNode, endNode) {\n    const visited = [];\n    let unvisited = getAllNodes(grid);\n    startNode.distance = 0;\n    unvisited[startNode.row][startNode.col] = startNode\n    /*\n    if (!startNode || !endNode || startNode === endNode) {\n        return false;\n    } */\n    let i = 0;\n    while (unvisited.length) {\n        sortNodesByDistance(unvisited);\n        const currNode = unvisited.shift();\n        if (currNode.isWall) {\n            console.log(\"---DIJKSTRA HITS WALL---\");\n            console.log(currNode.row);\n            console.log(currNode.col);\n            console.log(\"------------------------\");\n            continue;\n        }\n        //handles situations where there is no possible path to endNode\n        if (currNode.distance === Infinity) {\n            return visited;\n        }\n        currNode.visited = true;\n        visited.push(currNode);\n        if (currNode === endNode) {\n            return visited;\n        }\n        updateNeighbors(currNode, grid);\n    }\n}\n\nfunction sortNodesByDistance(unvisited) {\n    unvisited.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateNeighbors(node, grid) {\n    const neighbors = getNeighbors(node, grid);\n    for (const neighbor of neighbors) {\n        const distance = node.distance + 1\n        if (!neighbor.visited) {\n            neighbor.distance = distance;\n            neighbor.previous = node;\n        }\n    }\n}\n\nfunction getNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) {\n        neighbors.push(grid[row-1][col]);\n    }\n    if (row<(grid.length-1)) neighbors.push(grid[row+1][col]);\n    if (col > 0) neighbors.push(grid[row][col-1]);\n    if (col < (grid[0].length-1)) neighbors.push(grid[row][col+1]);\n    return neighbors;\n}\n\nfunction getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}","/Users/julietsampson/gh-website/src/index.js",[],[],"/Users/julietsampson/gh-website/src/App.js",["73"],[],"/Users/julietsampson/gh-website/src/reportWebVitals.js",[],[],"/Users/julietsampson/gh-website/src/Pathfinder/Pathfinder.jsx",["74","75"],[],"/Users/julietsampson/gh-website/src/algorithms/dijkstra.js",["76","77"],[],"/Users/julietsampson/gh-website/src/Pathfinder/Node/Node.jsx",["78"],[],{"ruleId":"79","severity":1,"message":"80","line":1,"column":8,"nodeType":"81","messageId":"82","endLine":1,"endColumn":12},{"ruleId":"79","severity":1,"message":"83","line":5,"column":10,"nodeType":"81","messageId":"82","endLine":5,"endColumn":16},{"ruleId":"84","severity":1,"message":"85","line":44,"column":19,"nodeType":"86","messageId":"87","endLine":44,"endColumn":21},{"ruleId":"79","severity":1,"message":"83","line":1,"column":10,"nodeType":"81","messageId":"82","endLine":1,"endColumn":16},{"ruleId":"79","severity":1,"message":"88","line":1,"column":5,"nodeType":"81","messageId":"82","endLine":1,"endColumn":9},{"ruleId":"79","severity":1,"message":"89","line":17,"column":9,"nodeType":"81","messageId":"82","endLine":17,"endColumn":10},{"ruleId":"79","severity":1,"message":"80","line":1,"column":8,"nodeType":"81","messageId":"82","endLine":1,"endColumn":12},{"ruleId":"79","severity":1,"message":"83","line":5,"column":10,"nodeType":"81","messageId":"82","endLine":5,"endColumn":16},{"ruleId":"84","severity":1,"message":"85","line":44,"column":19,"nodeType":"86","messageId":"87","endLine":44,"endColumn":21},{"ruleId":"79","severity":1,"message":"88","line":1,"column":5,"nodeType":"81","messageId":"82","endLine":1,"endColumn":9},{"ruleId":"79","severity":1,"message":"89","line":17,"column":9,"nodeType":"81","messageId":"82","endLine":17,"endColumn":10},{"ruleId":"79","severity":1,"message":"83","line":1,"column":10,"nodeType":"81","messageId":"82","endLine":1,"endColumn":16},"no-unused-vars","'logo' is defined but never used.","Identifier","unusedVar","'render' is defined but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'node' is assigned a value but never used.","'i' is assigned a value but never used."]