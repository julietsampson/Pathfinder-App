{"ast":null,"code":"let node = {\n  row: 0,\n  col: 0,\n  visited: false,\n  distance: Infinity\n};\nexport default function dijkstra(grid, startNode, endNode) {\n  const visited = [];\n  startNode.distance = 0;\n  const unvisited = getAllNodes(grid);\n  /*\n  if (!startNode || !endNode || startNode === endNode) {\n      return false;\n  } */\n\n  let i = 0;\n\n  while (unvisited.length) {\n    sortNodesByDistance(unvisited);\n    const currNode = unvisited.shift();\n\n    if (i === 0) {\n      console.log(\"---FIRST NODE---\");\n      console.log(currNode.row);\n      console.log(currNode.col);\n      console.log(currNode.distance);\n      console.log(\"----------------\");\n      i++;\n    } //handle walls, nonexistent path, and animation later\n\n    /*\n    while (currNode.status === \"wall\" && unvisited.length) {\n        currNode = closestNode(nodes, unvisited);\n    }\n    */\n\n    /*\n     if (currNode.distance === Infinity) {\n         return false;\n     }\n     */\n\n\n    currNode.visited = true;\n    visited.push(currNode);\n\n    if (currNode === endNode) {\n      return visited;\n    }\n\n    updateNeighbors(currNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisited) {\n  unvisited.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateNeighbors(node, grid) {\n  const neighbors = getNeighbors(node, grid);\n\n  for (const neighbor of neighbors) {\n    const distance = node.distance + 1;\n\n    if (!neighbor.visited) {\n      neighbor.distance = distance;\n    }\n  }\n}\n\nfunction getNeighbors(node, grid) {\n  const neighbors = [];\n  const {\n    col,\n    row\n  } = node;\n\n  if (row > 0) {\n    neighbors.push(grid[row - 1][col]);\n  }\n\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors;\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n}","map":{"version":3,"names":["node","row","col","visited","distance","Infinity","dijkstra","grid","startNode","endNode","unvisited","getAllNodes","i","length","sortNodesByDistance","currNode","shift","console","log","push","updateNeighbors","sort","nodeA","nodeB","neighbors","getNeighbors","neighbor","nodes"],"sources":["/Users/julietsampson/pathfinder/src/algorithms/dijkstra.js"],"sourcesContent":["let node = {\n    row: 0,\n    col: 0,\n    visited: false,\n    distance: Infinity,\n}\n\nexport default function dijkstra(grid, startNode, endNode) {\n    const visited = [];\n    startNode.distance = 0;\n    const unvisited = getAllNodes(grid);\n    /*\n    if (!startNode || !endNode || startNode === endNode) {\n        return false;\n    } */\n    let i = 0;\n    while (unvisited.length) {\n        sortNodesByDistance(unvisited);\n        const currNode = unvisited.shift();\n        if (i === 0) {\n            console.log(\"---FIRST NODE---\")\n            console.log(currNode.row);\n            console.log(currNode.col);\n            console.log(currNode.distance);\n            console.log(\"----------------\")\n            i++;\n        }\n        //handle walls, nonexistent path, and animation later\n        /*\n        while (currNode.status === \"wall\" && unvisited.length) {\n            currNode = closestNode(nodes, unvisited);\n        }\n        */\n       /*\n        if (currNode.distance === Infinity) {\n            return false;\n        }\n        */\n        currNode.visited = true;\n        visited.push(currNode);\n\n        if (currNode === endNode) {\n            return visited;\n        }\n        updateNeighbors(currNode, grid);\n    }\n}\n\nfunction sortNodesByDistance(unvisited) {\n    unvisited.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateNeighbors(node, grid) {\n    const neighbors = getNeighbors(node, grid);\n    for (const neighbor of neighbors) {\n        const distance = node.distance + 1\n        if (!neighbor.visited) {\n            neighbor.distance = distance;\n        }\n    }\n}\n\nfunction getNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) {\n        neighbors.push(grid[row-1][col]);\n    }\n    if (row<(grid.length-1)) neighbors.push(grid[row+1][col]);\n    if (col > 0) neighbors.push(grid[row][col-1]);\n    if (col < (grid[0].length-1)) neighbors.push(grid[row][col+1]);\n    return neighbors;\n}\n\nfunction getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}