{"ast":null,"code":"const node = {\n  row: 0,\n  col: 0,\n  visited: false,\n  distance: Infinity\n};\nexport default function dijkstra(grid, startNode, endNode) {\n  const visited = [];\n  startNode.distance = 0;\n  const unvisited = getAllNodes(grid);\n  /*\n  if (!startNode || !endNode || startNode === endNode) {\n      return false;\n  } */\n\n  while (unvisited.length) {\n    sortNodesByDistance(unvisited);\n    const currNode = unvisited.shift(); //handle walls, nonexistent path, and animation later\n\n    /*\n    while (currNode.status === \"wall\" && unvisited.length) {\n        currNode = closestNode(nodes, unvisited);\n    }\n    */\n\n    /*\n     if (currNode.distance === Infinity) {\n         return false;\n     }\n     */\n\n    currNode.visited = true;\n    visited.push(currNode);\n\n    if (currNode === endNode) {\n      return visited;\n    }\n\n    updateNeighbors(currNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisited) {\n  unvisited.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateNeighbors(node, grid) {\n  const neighbors = getNeighbors(node, grid);\n\n  for (const neighbor of neighbors) {\n    const distance = node.distance + 1;\n\n    if (!neighbor.visited) {\n      neighbor.distance = distance;\n    }\n  }\n}\n\nfunction getNeighbors(node, grid) {\n  const neighbors = [];\n  const {\n    col,\n    row\n  } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors;\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n}","map":{"version":3,"names":["node","row","col","visited","distance","Infinity","dijkstra","grid","startNode","endNode","unvisited","getAllNodes","length","sortNodesByDistance","currNode","shift","push","updateNeighbors","sort","nodeA","nodeB","neighbors","getNeighbors","neighbor","nodes"],"sources":["/Users/julietsampson/pathfinder/src/algorithms/dijkstra.js"],"sourcesContent":["const node = {\n    row: 0,\n    col: 0,\n    visited: false,\n    distance: Infinity,\n}\n\nexport default function dijkstra(grid, startNode, endNode) {\n    const visited = [];\n    startNode.distance = 0;\n    const unvisited = getAllNodes(grid);\n    /*\n    if (!startNode || !endNode || startNode === endNode) {\n        return false;\n    } */\n    while (unvisited.length) {\n        sortNodesByDistance(unvisited);\n        const currNode = unvisited.shift();\n        //handle walls, nonexistent path, and animation later\n        /*\n        while (currNode.status === \"wall\" && unvisited.length) {\n            currNode = closestNode(nodes, unvisited);\n        }\n        */\n       /*\n        if (currNode.distance === Infinity) {\n            return false;\n        }\n        */\n        currNode.visited = true;\n        visited.push(currNode);\n\n        if (currNode === endNode) {\n            return visited;\n        }\n        updateNeighbors(currNode, grid);\n    }\n}\n\nfunction sortNodesByDistance(unvisited) {\n    unvisited.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateNeighbors(node, grid) {\n    const neighbors = getNeighbors(node, grid);\n    for (const neighbor of neighbors) {\n        const distance = node.distance + 1\n        if (!neighbor.visited) {\n            neighbor.distance = distance;\n        }\n    }\n}\n\nfunction getNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row-1][col]);\n    if (row<(grid.length-1)) neighbors.push(grid[row+1][col]);\n    if (col > 0) neighbors.push(grid[row][col-1]);\n    if (col < (grid[0].length-1)) neighbors.push(grid[row][col+1]);\n    return neighbors;\n}\n\nfunction getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}"],"mappings":"AAAA,MAAMA,IAAI,GAAG;EACTC,GAAG,EAAE,CADI;EAETC,GAAG,EAAE,CAFI;EAGTC,OAAO,EAAE,KAHA;EAITC,QAAQ,EAAEC;AAJD,CAAb;AAOA,eAAe,SAASC,QAAT,CAAkBC,IAAlB,EAAwBC,SAAxB,EAAmCC,OAAnC,EAA4C;EACvD,MAAMN,OAAO,GAAG,EAAhB;EACAK,SAAS,CAACJ,QAAV,GAAqB,CAArB;EACA,MAAMM,SAAS,GAAGC,WAAW,CAACJ,IAAD,CAA7B;EACA;AACJ;AACA;AACA;;EACI,OAAOG,SAAS,CAACE,MAAjB,EAAyB;IACrBC,mBAAmB,CAACH,SAAD,CAAnB;IACA,MAAMI,QAAQ,GAAGJ,SAAS,CAACK,KAAV,EAAjB,CAFqB,CAGrB;;IACA;AACR;AACA;AACA;AACA;;IACO;AACP;AACA;AACA;AACA;;IACQD,QAAQ,CAACX,OAAT,GAAmB,IAAnB;IACAA,OAAO,CAACa,IAAR,CAAaF,QAAb;;IAEA,IAAIA,QAAQ,KAAKL,OAAjB,EAA0B;MACtB,OAAON,OAAP;IACH;;IACDc,eAAe,CAACH,QAAD,EAAWP,IAAX,CAAf;EACH;AACJ;;AAED,SAASM,mBAAT,CAA6BH,SAA7B,EAAwC;EACpCA,SAAS,CAACQ,IAAV,CAAe,CAACC,KAAD,EAAQC,KAAR,KAAkBD,KAAK,CAACf,QAAN,GAAiBgB,KAAK,CAAChB,QAAxD;AACH;;AAED,SAASa,eAAT,CAAyBjB,IAAzB,EAA+BO,IAA/B,EAAqC;EACjC,MAAMc,SAAS,GAAGC,YAAY,CAACtB,IAAD,EAAOO,IAAP,CAA9B;;EACA,KAAK,MAAMgB,QAAX,IAAuBF,SAAvB,EAAkC;IAC9B,MAAMjB,QAAQ,GAAGJ,IAAI,CAACI,QAAL,GAAgB,CAAjC;;IACA,IAAI,CAACmB,QAAQ,CAACpB,OAAd,EAAuB;MACnBoB,QAAQ,CAACnB,QAAT,GAAoBA,QAApB;IACH;EACJ;AACJ;;AAED,SAASkB,YAAT,CAAsBtB,IAAtB,EAA4BO,IAA5B,EAAkC;EAC9B,MAAMc,SAAS,GAAG,EAAlB;EACA,MAAM;IAACnB,GAAD;IAAMD;EAAN,IAAaD,IAAnB;EACA,IAAIC,GAAG,GAAG,CAAV,EAAaoB,SAAS,CAACL,IAAV,CAAeT,IAAI,CAACN,GAAG,GAAC,CAAL,CAAJ,CAAYC,GAAZ,CAAf;EACb,IAAID,GAAG,GAAEM,IAAI,CAACK,MAAL,GAAY,CAArB,EAAyBS,SAAS,CAACL,IAAV,CAAeT,IAAI,CAACN,GAAG,GAAC,CAAL,CAAJ,CAAYC,GAAZ,CAAf;EACzB,IAAIA,GAAG,GAAG,CAAV,EAAamB,SAAS,CAACL,IAAV,CAAeT,IAAI,CAACN,GAAD,CAAJ,CAAUC,GAAG,GAAC,CAAd,CAAf;EACb,IAAIA,GAAG,GAAIK,IAAI,CAAC,CAAD,CAAJ,CAAQK,MAAR,GAAe,CAA1B,EAA8BS,SAAS,CAACL,IAAV,CAAeT,IAAI,CAACN,GAAD,CAAJ,CAAUC,GAAG,GAAC,CAAd,CAAf;EAC9B,OAAOmB,SAAP;AACH;;AAED,SAASV,WAAT,CAAqBJ,IAArB,EAA2B;EACvB,MAAMiB,KAAK,GAAG,EAAd;;EACA,KAAK,MAAMvB,GAAX,IAAkBM,IAAlB,EAAwB;IACpB,KAAK,MAAMP,IAAX,IAAmBC,GAAnB,EAAwB;MACpBuB,KAAK,CAACR,IAAN,CAAWhB,IAAX;IACH;EACJ;;EACD,OAAOwB,KAAP;AACH"},"metadata":{},"sourceType":"module"}