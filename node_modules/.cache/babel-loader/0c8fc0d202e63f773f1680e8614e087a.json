{"ast":null,"code":"let node = {\n  row: 0,\n  col: 0,\n  visited: false,\n  distance: Infinity\n};\nexport default function dijkstra(grid, startNode, endNode) {\n  const visited = [];\n  let unvisited = getAllNodes(grid);\n  startNode.distance = 0;\n  unvisited[startNode.row][startNode.col] = startNode;\n  /*\n  if (!startNode || !endNode || startNode === endNode) {\n      return false;\n  } */\n\n  let i = 0;\n\n  while (unvisited.length) {\n    sortNodesByDistance(unvisited);\n    const currNode = unvisited.shift();\n    if (currNode.isWall) continue; //handles situations where there is no possible path to endNode\n\n    if (currNode.distance === Infinity) {\n      return visited;\n    }\n\n    visited.push(currNode);\n\n    if (currNode === endNode) {\n      return visited;\n    }\n\n    updateNeighbors(currNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisited) {\n  unvisited.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateNeighbors(node, grid) {\n  const neighbors = getNeighbors(node, grid);\n\n  for (const neighbor of neighbors) {\n    const distance = node.distance + 1;\n\n    if (!neighbor.visited) {\n      neighbor.distance = distance;\n    }\n  }\n}\n\nfunction getNeighbors(node, grid) {\n  const neighbors = [];\n  const {\n    col,\n    row\n  } = node;\n\n  if (row > 0) {\n    neighbors.push(grid[row - 1][col]);\n  }\n\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors;\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n}","map":{"version":3,"names":["node","row","col","visited","distance","Infinity","dijkstra","grid","startNode","endNode","unvisited","getAllNodes","i","length","sortNodesByDistance","currNode","shift","isWall","push","updateNeighbors","sort","nodeA","nodeB","neighbors","getNeighbors","neighbor","nodes"],"sources":["/Users/julietsampson/pathfinder/src/algorithms/dijkstra.js"],"sourcesContent":["let node = {\n    row: 0,\n    col: 0,\n    visited: false,\n    distance: Infinity,\n}\n\nexport default function dijkstra(grid, startNode, endNode) {\n    const visited = [];\n    let unvisited = getAllNodes(grid);\n    startNode.distance = 0;\n    unvisited[startNode.row][startNode.col] = startNode\n    /*\n    if (!startNode || !endNode || startNode === endNode) {\n        return false;\n    } */\n    let i = 0;\n    while (unvisited.length) {\n        sortNodesByDistance(unvisited);\n        const currNode = unvisited.shift();\n        if (currNode.isWall) continue;\n        //handles situations where there is no possible path to endNode\n        if (currNode.distance === Infinity) {\n            return visited;\n        }\n        visited.push(currNode);\n        if (currNode === endNode) {\n            return visited;\n        }\n        updateNeighbors(currNode, grid);\n    }\n}\n\nfunction sortNodesByDistance(unvisited) {\n    unvisited.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateNeighbors(node, grid) {\n    const neighbors = getNeighbors(node, grid);\n    for (const neighbor of neighbors) {\n        const distance = node.distance + 1\n        if (!neighbor.visited) {\n            neighbor.distance = distance;\n        }\n    }\n}\n\nfunction getNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) {\n        neighbors.push(grid[row-1][col]);\n    }\n    if (row<(grid.length-1)) neighbors.push(grid[row+1][col]);\n    if (col > 0) neighbors.push(grid[row][col-1]);\n    if (col < (grid[0].length-1)) neighbors.push(grid[row][col+1]);\n    return neighbors;\n}\n\nfunction getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}