{"ast":null,"code":"let node = {\n  row: 0,\n  col: 0,\n  visited: false,\n  distance: Infinity\n};\nexport default function dijkstra(grid, startNode, endNode) {\n  const visited = [];\n  let unvisited = getAllNodes(grid);\n  startNode.distance = 0;\n  unvisited[startNode.row][startNode.col] = startNode;\n  /*\n  if (!startNode || !endNode || startNode === endNode) {\n      return false;\n  } */\n\n  let i = 0;\n\n  while (unvisited.length) {\n    sortNodesByDistance(unvisited);\n    const currNode = unvisited.shift();\n\n    if (currNode.isWall) {\n      console.log(\"---DIJKSTRA HITS WALL---\");\n      console.log(currNode.row);\n      console.log(currNode.col);\n      console.log(\"------------------------\");\n      continue;\n    } //handles situations where there is no possible path to endNode\n\n\n    if (currNode.distance === Infinity) {\n      return visited;\n    }\n\n    currNode.visited = true;\n    visited.push(currNode);\n\n    if (currNode === endNode) {\n      return visited;\n    }\n\n    updateNeighbors(currNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisited) {\n  unvisited.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateNeighbors(node, grid) {\n  const neighbors = getNeighbors(node, grid);\n\n  for (const neighbor of neighbors) {\n    const distance = node.distance + 1;\n\n    if (!neighbor.visited) {\n      neighbor.distance = distance;\n      neighbor.previous = node;\n    }\n  }\n}\n\nfunction getNeighbors(node, grid) {\n  const neighbors = [];\n  const {\n    col,\n    row\n  } = node;\n\n  if (row > 0) {\n    neighbors.push(grid[row - 1][col]);\n  }\n\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors;\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n}","map":{"version":3,"names":["node","row","col","visited","distance","Infinity","dijkstra","grid","startNode","endNode","unvisited","getAllNodes","i","length","sortNodesByDistance","currNode","shift","isWall","console","log","push","updateNeighbors","sort","nodeA","nodeB","neighbors","getNeighbors","neighbor","previous","nodes"],"sources":["/Users/julietsampson/pathfinder/src/algorithms/dijkstra.js"],"sourcesContent":["let node = {\n    row: 0,\n    col: 0,\n    visited: false,\n    distance: Infinity,\n}\n\nexport default function dijkstra(grid, startNode, endNode) {\n    const visited = [];\n    let unvisited = getAllNodes(grid);\n    startNode.distance = 0;\n    unvisited[startNode.row][startNode.col] = startNode\n    /*\n    if (!startNode || !endNode || startNode === endNode) {\n        return false;\n    } */\n    let i = 0;\n    while (unvisited.length) {\n        sortNodesByDistance(unvisited);\n        const currNode = unvisited.shift();\n        if (currNode.isWall) {\n            console.log(\"---DIJKSTRA HITS WALL---\");\n            console.log(currNode.row);\n            console.log(currNode.col);\n            console.log(\"------------------------\");\n            continue;\n        }\n        //handles situations where there is no possible path to endNode\n        if (currNode.distance === Infinity) {\n            return visited;\n        }\n        currNode.visited = true;\n        visited.push(currNode);\n        if (currNode === endNode) {\n            return visited;\n        }\n        updateNeighbors(currNode, grid);\n    }\n}\n\nfunction sortNodesByDistance(unvisited) {\n    unvisited.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateNeighbors(node, grid) {\n    const neighbors = getNeighbors(node, grid);\n    for (const neighbor of neighbors) {\n        const distance = node.distance + 1\n        if (!neighbor.visited) {\n            neighbor.distance = distance;\n            neighbor.previous = node;\n        }\n    }\n}\n\nfunction getNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) {\n        neighbors.push(grid[row-1][col]);\n    }\n    if (row<(grid.length-1)) neighbors.push(grid[row+1][col]);\n    if (col > 0) neighbors.push(grid[row][col-1]);\n    if (col < (grid[0].length-1)) neighbors.push(grid[row][col+1]);\n    return neighbors;\n}\n\nfunction getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}